
# CodeitSprint_WeeklyPaper-5th
About eventDelegation_And_HTTP_Method

## Event Delegation
Event Delegation (이벤트 위임)이란, 요소에 할당된 이벤트가 발동했을 때, 그 요소와 상하 관계로 연결된 요소에도 동일한 이벤트가 발동하는 현상을 의미한다. 이때, 이 이벤트가 연쇄되는 방향에 따라 Bubbling과 Capturing으로 나뉜다.
이때, 이벤트가 발생한 요소의 Handler의 스크립트 또한 실행한다.

이는 Handler의 작동 원리에서 부수적으로 나타난 현상인데, 최상위 요소 HTML에서 요소를 따라 순차적으로 Handler를 호출한 요소에 도착한 후, 관련 정보를 최상위 요소로 전달하는 과정에서 거쳐가는 순차적인 과정에서 기인한 것이기 때문이다.

이러한 방법을 이용해 각 요소가 아닌 부모 요소에 할당하여 코드의 간략화를 이끌어 낼 수 있다.

### Bubbling
Bubbling은 이벤트가 발생 했을 때, 발동 요소에서 최상위 요소로 이벤트가 거슬러 올라가는 현상을 의미한다. 예를 들어,
 
  > Form 1
  >> Form 2
  >>> Form 3
  >>> 
  >> .
  >> 
  > .

와 같은 식의 구조로 되어 있을 때, Form 3에서 발생한 이벤트는 Form 1 까지 위임되어 호출된다.

'거의 모든' 이벤트는 버블링 된다. - 그러나 focus 이벤트와 같이 버블링 되지 않는 이벤트도 있으므로, 각 이벤트의 특성을 정확하게 알고 있어야 한다.

### Capturing
Capturing은 이벤트가 발생 했을 때, 최상위 요소에서 발동 요소로 이벤트가 거슬러 내려가는 현상을 의미한다. 즉,
 
  > Form 1
  >> Form 2
  >>> Form 3
  >>> 
  >> .
  >> 
  > .

와 같은 식의 구조로 되어 있을 때, Form 1에서 발생한 이벤트는 Form 3 까지 위임되어 호출된다.

캡처링 단계를 이용해야 하는 경우는 흔하지 않으므로 Handler는 Capturing 설정이 기본적으로 비활성화되어있으며, addEventListener의 capture 옵션을 true로 설정해 활성화를 해야한다.
> addEventListener( ...... , {capture: true})
>
> 또는
>
> addEventListener( ...... , true)

### EventTarget
부모 요소의 핸들러는 이벤트가 정확히 어디서 발생했는지 등에 대한 자세한 정보를 얻을 수 있다.

이벤트가 발생한 가장 안쪽의 요소는 타깃(target) 요소라고 불리고, event.target을 사용해 접근할 수 있다.

event.target과 this(=event.currentTarget)는 다음과 같은 차이점이 있습니다.

> event.target은 실제 이벤트가 시작된 ‘타깃’ 요소이다. 버블링이 진행되어도 변하지 않는다.

> this는 버블링으로 위임된 '현재' 요소로, 현재 실행 중인 핸들러가 할당된 요소를 참조한다.

### Caution
이 현상들을 원하지 않는 경우 양 쪽 모두 다음 Method를 이용해 이러한 현상을 막을 수 있다.
 > evnet.stopPropagation();

그러나, 꼭 필요한 경우가 아니면 위의 Method는 권장되지 않는데, 이는 Web Analytics Service 때문이다.

Web Analytics Service는 사이트의 유저 동향이나 데이터를 쌓기 위한 것으로,  event bubbling을 통해 event를 탐지하고 데이터를 수집하는 경우가 할 때
StopPropagation을 사용할 경우 event bubbling이 일어나지 않아 해당 툴이 클릭을 캡쳐하지 못할 수 있다.

사실 이러한 경우를 반드시 막아야 하는 경우는 흔하지 않으며, 간단히 동작하고자 하는 요소에 대한 제한사항을 거는 등의 방법으로도 버블링으로 인한 이벤트 연쇄를 막을 수 있다.
그러므로 stopPropagation은 완전히 통제된 상황이 아닌이상 사용하지 않아야 한다.

## HTTP Method
HTTP Method란, 클라이언트 - 서버 구조에서 서버 구조가 수행할 동작을 지정하여 Request와 Response가 이루어지는 방식이다.

이는 리소스와 동작을 분리하여 URL로 하여금 리소스만 식별하게 하기 위함으로, 종류는 크게 8가지가 있다.

> 멱등성
>
> 동일한 연산을 여러번 반복하여 전송하더라도 동일한 응답이 돌아오는 성질

### Get(멱등성) - 리소스 조회
기본적으로 지정되어있는 메소드이므로 별다른 메소드를 지정하지 않을 경우 이 메소드를 사용한다.

리퀘스트 바디를 사용하지 않고 쿼리 스트링을 사용한다. 이때, 불필요한 리퀘스트를 제한하기 위해 리퀘스트가 캐시될 수 있으며, 데이터 변경이 일어나지 않는다.

### Post - 데이터 추가/등록
새로운 리소스를 생성하거나 기존 리소스를 수정하기 위해 서버에 데이터를 보내는 메소드이다.

일반적으로 캐시되지 않으며, 리퀘스트 바디를 사용한다. 이때 리소스를 post한 경우, 이미 리소스가 있더라도 새로운 리소스를 생성한다.
이로 인하여 서버의 데이터 변경이 일어날 수 있다.

### put(멱등성) - 리소스 대체/수정
새로운 리소스를 생성하거나 기존 리소스를 수정하기 위해 서버에 데이터를 보내는 메소드이다.

서버에 리소스가 없으면 생성하지만, post와 다르게 있으면 클라이언트가 보낸 데이터로 대체하고 추가로 생성하진 않는다.

### Delete(멱등성) - 리소스 삭제
지정한 리소스를 삭제하는 메소드이며, 서버의 데이터를 삭제해달라는 리퀘스트를 보낸다.

### Patch - 리소스 부분 변경
PUT 리퀘스트가 데이터를 완전히 대체하는 것이라면, PATCH는 기존 리소스의 부분 수정을 위한 메소드입니다.

기존의 데이터에서 특정 부분을 수정해야 하지만, 그 특정 데이터의 전체 데이터를 대체하는 것이 아니라 단순히 내용물 한 가지만 바꿀 필요가 있을 때 사용한다.

### Head(멱등성) - Head 정보의 Get
특정 리소스를 GET 메소드로 요청했을 때 돌아올 헤더를 받기 위한 메소드이다.

실제 데이터가 아니라 데이터에 관한 정보만 얻으려고 하는 상황에 활용하며, 불필요한 리퀘스트를 제한하기 위해 리퀘스트가 캐시될 수 있습니다.

### Options(멱등성) - 서버와 브라우저간의 통신옵션 확인
주어진 URL 또는 서버에 대해 허용된 통신 옵션을 받기 위한 메소드이다.

허용된 리퀘스트 메소드를 확인하거나 리소스에 대해 지원하는 옵션을 확인할 때 사용합니다.

### Connect - 대상 서버에 대한 연결 요청
요청한 리소스에 대해 양방향 연결을 시작하는 메소드이며, SSL을 사용하는 웹사이트(HTTPS)에 접속하는데 사용될 수 있다.
